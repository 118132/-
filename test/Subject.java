package test;

public interface Subject {
	public void rent();
	public void hello(String str);
}

/*
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 
3. 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。
*/

/*
 Proxy是一种结构型设计模式，可以解决直接访问对象带来的问题。
 其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。
 通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。
 代理解决的问题当两个类需要通信时，引入第三方代理类，将两个类的关系解耦，让我们只了解代理类即可，而且代理的出现还可以让我们完成与另一个类之间的关系的统一管理。
方便有效的管理对象。
代理的两种模式：
 静态：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。
动态：在程序运行时运用反射机制动态创建而成。

静态代理：
在客户端而言可以不知道实现类是什么，能够在客户端前隐藏具体的实现。
同时，代理类和委托类实现了相同的接口，以及相同的方法，使产生了大量的代码重复。要使一个接口增加一个方法，会要使所有代理类也要实现这样的方法，增加了代码的维护的复杂度。
代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。
静态代理类只能为特定的接口(Service)服务。如想要为多个接口服务则需要建立很多个代理类。

动态代理：
可以通过一个代理类完成全部的代理功能。
动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象
被代理对象targetObject通过参数传递进来，我们通过targetObject.getClass().getClassLoader()获取ClassLoader对象，然后通过targetObject.getClass().getInterfaces()获取它实现的所有接口，然后将targetObject包装到实现了InvocationHandler接口的LogHandler对象中。通过newProxyInstance函数我们就获得了一个动态代理对象。
接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使我们的类职责更加单一，复用性更强
动态代理只是对类做了进一步抽象和封装。

 */